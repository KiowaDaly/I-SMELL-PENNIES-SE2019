Index: src/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n\r\n\r\nimport BloatCheckers.BloatedCodeAbuseCheck;\r\nimport BloatCheckers.ClassBloatChecks;\r\nimport BloatCheckers.MethodBloatChecks;\r\nimport ObjectOrientedAbusers.SwitchChecker;\r\nimport ProjectReader.FileChooser;\r\nimport com.github.javaparser.ast.CompilationUnit;\r\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\r\nimport com.github.javaparser.ast.body.MethodDeclaration;\r\nimport com.github.javaparser.StaticJavaParser;\r\nimport com.github.javaparser.ast.visitor.GenericVisitorAdapter;\r\nimport com.github.javaparser.ast.visitor.VoidVisitor;\r\nimport utility_classes.CompilationUnitVisitor;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\npublic class Main {\r\n    private static final String FILE_PATH = \"src/test.java\";\r\n\r\n    public static void main(String[] argc) throws Exception {\r\n\r\n        FileChooser FileExplorer = new FileChooser();\r\n        File ourProject = FileExplorer.selectFolder();\r\n        loopFolders(ourProject);\r\n    }\r\n\r\n    public static void loopFolders(File f) throws FileNotFoundException {\r\n        File[] folders = f.listFiles();\r\n        File[] Files = f.listFiles((dir, name) -> name.toLowerCase().endsWith(\".java\"));\r\n\r\n        for(File fi:folders){\r\n            if(fi.isDirectory()){\r\n                loopFolders(fi);\r\n            }\r\n            else{\r\n                    compUnitLoop(fi);\r\n            }\r\n\r\n\r\n        }\r\n    }\r\n    public static void compUnitLoop(File fi) throws FileNotFoundException {\r\n        CompilationUnit cu = StaticJavaParser.parse(fi);\r\n        ClassBloatChecks check_bloat = new ClassBloatChecks();\r\n        MethodBloatChecks method_bloat = new MethodBloatChecks();\r\n        SwitchChecker switchAnalysis = new SwitchChecker();\r\n        List<ClassOrInterfaceDeclaration> classes = new ArrayList<>();\r\n        CompilationUnitVisitor compunitvisitor = new CompilationUnitVisitor();\r\n        compunitvisitor.visit(cu, classes);\r\n//        for(ClassOrInterfaceDeclaration n:classes){\r\n//            System.out.println();\r\n//            System.out.println(\"====== TESTING \" + n.getNameAsString().toUpperCase()+\" ======\\n\");\r\n//            System.out.println(\"Number of lines: \"+ check_bloat.getNumLines(n));\r\n//            System.out.println(\"Number of Comments: \"+ check_bloat.getNumComments(n));\r\n//            System.out.println(\"Number of fields: \"+ check_bloat.getNumFieldsOrVariables(n));\r\n//            System.out.println(\"Number of methods: \"+ check_bloat.getNumMethods(n));\r\n//            System.out.println(\"\\nNumber of switches: \"+ switchAnalysis.getNumberOfSwitches(n));\r\n//            System.out.println(\"\\nComplexity of the switch statements: \"+switchAnalysis.complexityOfClass(n));\r\n//            for (MethodDeclaration m:n.getMethods()) {\r\n//                System.out.println(\"\\n=================================\");\r\n//                System.out.println(\"Method: \" + m.getNameAsString());\r\n//                System.out.println(\"Number of Lines: \"+ method_bloat.getNumLines(m));\r\n//                System.out.println(\"Number of Comments: \"+ method_bloat.getNumComments(m));\r\n//                System.out.println(\"Number of parameter: \"+ method_bloat.getNumParameters(m));\r\n//                System.out.println(\"Number of Variables: \"+ method_bloat.getNumFieldsOrVariables(m));\r\n//                System.out.println(\"\");\r\n//\r\n//            }\r\n//        }\r\n        BloatedCodeAbuseCheck checkBloats = new BloatedCodeAbuseCheck(classes);\r\n        HashMap<ClassOrInterfaceDeclaration,HashMap> map = checkBloats.getClassThreats();\r\n        checkBloats.performBloatChecks();\r\n        for (ClassOrInterfaceDeclaration cl : map.keySet()) {\r\n            HashMap value = map.get(cl);\r\n            Set<BloatedCodeAbuseCheck.ThreatLevel> t =  value.keySet();\r\n            for(BloatedCodeAbuseCheck.ThreatLevel tl:t ){\r\n                System.out.println(\"CLASS: \"+cl.getNameAsString().toUpperCase()+\" has a Bloat threat level of: \"+tl.toString());\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Main.java	(revision 9c56dbcbe8bd755423720c38425c3e6f1311cb18)
+++ src/Main.java	(date 1554842446444)
@@ -48,9 +48,9 @@
     }
     public static void compUnitLoop(File fi) throws FileNotFoundException {
         CompilationUnit cu = StaticJavaParser.parse(fi);
-        ClassBloatChecks check_bloat = new ClassBloatChecks();
-        MethodBloatChecks method_bloat = new MethodBloatChecks();
-        SwitchChecker switchAnalysis = new SwitchChecker();
+//        ClassBloatChecks check_bloat = new ClassBloatChecks();
+//        MethodBloatChecks method_bloat = new MethodBloatChecks();
+//        SwitchChecker switchAnalysis = new SwitchChecker();
         List<ClassOrInterfaceDeclaration> classes = new ArrayList<>();
         CompilationUnitVisitor compunitvisitor = new CompilationUnitVisitor();
         compunitvisitor.visit(cu, classes);
Index: src/BloatCheckers/BloatedCodeAbuseCheck.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BloatCheckers;\r\n\r\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\r\nimport com.github.javaparser.ast.body.MethodDeclaration;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\n\r\npublic class BloatedCodeAbuseCheck {\r\n    public enum ThreatLevel{\r\n        NONE,LOW,MEDIUM,HIGH\r\n    }\r\n    private final int METHOD_THRESHOLD = 15;\r\n    private final double COMMENT_THRESHOLD = 1;\r\n    private final int CLASS_LENGTH_THRESHOLD = 200;\r\n    private final int VARIABLE_THRESHOLD = 20;\r\n    final int METHOD_LINE_THRESHOLD = 30;\r\n    final int PARAMETER_THRESHOLD = 5;\r\n    private ClassBloatChecks check_bloat = new ClassBloatChecks();\r\n    private MethodBloatChecks method_bloat = new MethodBloatChecks();\r\n    private List<ClassOrInterfaceDeclaration> classes;\r\n\r\n    private HashMap<ClassOrInterfaceDeclaration,HashMap> classThreats = new HashMap<>();\r\n\r\n    private HashMap<MethodDeclaration,HashMap> MethodThreats = new HashMap<>();\r\n\r\n    public BloatedCodeAbuseCheck(List<ClassOrInterfaceDeclaration> classes){\r\n            this.classes = classes;\r\n    }\r\n\r\n    public void performBloatChecks(){\r\n        for(ClassOrInterfaceDeclaration cl:classes){\r\n            classThreats.put(cl,CheckClass(cl));\r\n        }\r\n    }\r\n\r\n    private HashMap CheckClass(ClassOrInterfaceDeclaration n){\r\n            int threatValue = 0;\r\n            int classLength = check_bloat.getNumLines(n);\r\n            threatValue += (classLength > CLASS_LENGTH_THRESHOLD)?1:0;\r\n            threatValue += ((classLength-check_bloat.getNumComments(n))/classLength < COMMENT_THRESHOLD) ? 1:0;\r\n            threatValue += (check_bloat.getNumFieldsOrVariables(n) > VARIABLE_THRESHOLD) ? 1:0;\r\n            threatValue += (check_bloat.getNumMethods(n) > METHOD_THRESHOLD) ? 1:0;\r\n            for (MethodDeclaration m:n.getMethods()) {\r\n                MethodThreats.put(m,CheckMethod(m));\r\n            }\r\n            HashMap<ThreatLevel,Integer> threatPercentageHelper = new HashMap<>();\r\n            int temp = threatValue;\r\n            threatValue = (threatValue > 3) ? 3:threatValue;\r\n            threatPercentageHelper.put(ThreatLevel.values()[threatValue],temp);\r\n            return threatPercentageHelper;\r\n    }\r\n\r\n    private HashMap CheckMethod(MethodDeclaration m){\r\n\r\n            int threatValue  = 0;\r\n            int methodLines = method_bloat.getNumLines(m);\r\n            threatValue += (methodLines > METHOD_LINE_THRESHOLD) ? 1:0;\r\n            threatValue += ((methodLines - method_bloat.getNumComments(m))/100 > COMMENT_THRESHOLD) ? 1:0;\r\n            threatValue += (method_bloat.getNumParameters(m) > PARAMETER_THRESHOLD) ? 1:0;\r\n            threatValue += (method_bloat.getNumFieldsOrVariables(m) > VARIABLE_THRESHOLD) ? 1:0;\r\n            HashMap<ThreatLevel,Integer> threatPercentageHelper = new HashMap<>();\r\n            int temp = threatValue;\r\n            threatValue = (threatValue > 3) ? 3:threatValue;\r\n            threatPercentageHelper.put(ThreatLevel.values()[threatValue],temp);\r\n            return threatPercentageHelper;\r\n    }\r\n\r\n    public HashMap getMethodThreats(){\r\n            return MethodThreats;\r\n    }\r\n    public HashMap getClassThreats(){\r\n            return classThreats;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/BloatCheckers/BloatedCodeAbuseCheck.java	(revision 9c56dbcbe8bd755423720c38425c3e6f1311cb18)
+++ src/BloatCheckers/BloatedCodeAbuseCheck.java	(date 1554466796301)
@@ -1,8 +1,6 @@
 package BloatCheckers;
-
 import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
 import com.github.javaparser.ast.body.MethodDeclaration;
-
 import java.util.HashMap;
 import java.util.List;
 
@@ -10,18 +8,12 @@
     public enum ThreatLevel{
         NONE,LOW,MEDIUM,HIGH
     }
-    private final int METHOD_THRESHOLD = 15;
     private final double COMMENT_THRESHOLD = 1;
-    private final int CLASS_LENGTH_THRESHOLD = 200;
     private final int VARIABLE_THRESHOLD = 20;
-    final int METHOD_LINE_THRESHOLD = 30;
-    final int PARAMETER_THRESHOLD = 5;
     private ClassBloatChecks check_bloat = new ClassBloatChecks();
     private MethodBloatChecks method_bloat = new MethodBloatChecks();
     private List<ClassOrInterfaceDeclaration> classes;
-
     private HashMap<ClassOrInterfaceDeclaration,HashMap> classThreats = new HashMap<>();
-
     private HashMap<MethodDeclaration,HashMap> MethodThreats = new HashMap<>();
 
     public BloatedCodeAbuseCheck(List<ClassOrInterfaceDeclaration> classes){
@@ -37,9 +29,11 @@
     private HashMap CheckClass(ClassOrInterfaceDeclaration n){
             int threatValue = 0;
             int classLength = check_bloat.getNumLines(n);
+            int CLASS_LENGTH_THRESHOLD = 200;
             threatValue += (classLength > CLASS_LENGTH_THRESHOLD)?1:0;
             threatValue += ((classLength-check_bloat.getNumComments(n))/classLength < COMMENT_THRESHOLD) ? 1:0;
             threatValue += (check_bloat.getNumFieldsOrVariables(n) > VARIABLE_THRESHOLD) ? 1:0;
+            int METHOD_THRESHOLD = 15;
             threatValue += (check_bloat.getNumMethods(n) > METHOD_THRESHOLD) ? 1:0;
             for (MethodDeclaration m:n.getMethods()) {
                 MethodThreats.put(m,CheckMethod(m));
@@ -52,11 +46,12 @@
     }
 
     private HashMap CheckMethod(MethodDeclaration m){
-
             int threatValue  = 0;
             int methodLines = method_bloat.getNumLines(m);
+            int METHOD_LINE_THRESHOLD = 30;
             threatValue += (methodLines > METHOD_LINE_THRESHOLD) ? 1:0;
             threatValue += ((methodLines - method_bloat.getNumComments(m))/100 > COMMENT_THRESHOLD) ? 1:0;
+            int PARAMETER_THRESHOLD = 5;
             threatValue += (method_bloat.getNumParameters(m) > PARAMETER_THRESHOLD) ? 1:0;
             threatValue += (method_bloat.getNumFieldsOrVariables(m) > VARIABLE_THRESHOLD) ? 1:0;
             HashMap<ThreatLevel,Integer> threatPercentageHelper = new HashMap<>();
